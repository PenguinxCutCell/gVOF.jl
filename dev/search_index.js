var documenterSearchIndex = {"docs":
[{"location":"types/#Types","page":"Types","title":"Types","text":"VOFParams stores runtime controls (reconstruction/advection methods, tolerances, grid dimensions, and time-stepping controls).\n\nVOFGrid stores the geometry, topology, and all VOF state arrays used by the algorithms.\n\nSee Reference for full API docstrings.","category":"section"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#gVOF.gVOF","page":"Reference","title":"gVOF.gVOF","text":"gVOF\n\nA Julia package implementing advanced unsplit geometric Volume of Fluid (VOF) methods on arbitrary grids, either structured or unstructured with convex or non-convex cells.\n\nTranslated from the Fortran gVOF library by J. Lopez and J. Hernandez (2021).\n\nReferences\n\nJ. Lopez and J. Hernandez, gVOF: An open-source package for unsplit geometric volume of fluid methods on arbitrary grids, Computer Physics Communications.\n\nDependencies\n\nISOAP – isosurface extraction on arbitrary polyhedra\nVOFTools – analytical and geometrical tools for VOF methods\n\n\n\n\n\n","category":"module"},{"location":"95-reference/#gVOF.VOFGrid","page":"Reference","title":"gVOF.VOFGrid","text":"VOFGrid\n\nA grid augmented with all the pre-computed quantities needed by the gVOF algorithms: face normals/areas, cell centres/volumes, bounding boxes, neighbour lists, etc.\n\nBuilt from an ISOAP.Grid via vofgrid.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#gVOF.VOFParams","page":"Reference","title":"gVOF.VOFParams","text":"VOFParams\n\nParameters controlling a gVOF simulation, typically read from a gvofvardef configuration file.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#gVOF._TagWork","page":"Reference","title":"gVOF._TagWork","text":"taggrid!(vg::VOFGrid, tolfr::Float64)\ntaggrid!(vg::VOFGrid; tolfr=1e-12)\n\nClassify every node, cell and face of the grid as empty (−1), interfacial (0) or full (+1) and build the lists\n\nvg.icint – interfacial cells (those with 0 < f < 1)\nvg.icadv – cells that need advection\nvg.isflu – faces requiring a geometric flux computation\n\nNodal volume fractions vg.frnod are obtained by Inverse-Distance Weighting (Shepard, p = 2) from the cell-centred values vg.fractg.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#gVOF._VofAdvWork","page":"Reference","title":"gVOF._VofAdvWork","text":"vofadv!(vg::VOFGrid, tolfr::Float64)\nvofadv!(vg::VOFGrid; tolfr=1e-12)\n\nAdvance the volume fraction field using the face fluxes vg.fface. Uses implicit divergence correction.\n\nUpdates vg.fractg and accumulates boundedness errors in vg.ebound.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#gVOF._allocate_vofgrid-Tuple{Grid}","page":"Reference","title":"gVOF._allocate_vofgrid","text":"_allocate_vofgrid(g::Grid) -> VOFGrid\n\nAllocate a VOFGrid wrapping g with zeroed arrays.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF._caracter-Tuple{Int64}","page":"Reference","title":"gVOF._caracter","text":"_caracter(i::Int) -> String\n\nConvert an integer 0–9999 to a zero-padded 4-character string.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF._enforce_volume-Tuple{VOFGrid, Int64, Polyhedron3D, Float64, Float64, Float64}","page":"Reference","title":"gVOF._enforce_volume","text":"_enforce_volume(vg, ic, poly, xnc, ync, znc) -> c\n\nChoose enforv3dsz for uniform grids and enforv3d for general grids.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.celldflux-Tuple{VOFGrid, Int64, Int64, Vararg{Float64, 6}}","page":"Reference","title":"gVOF.celldflux","text":"celldflux(vg, ic, igrid, xmin, xmax, ymin, ymax, zmin, zmax)\n    -> Vector of (isign, faces)\n\nFor igrid==3 (non-convex cells), decomposes the cell into convex sub-cells. Otherwise returns a single group containing all cell faces.\n\nEach element is (isign, xnf, ynf, znf, rhof) vectors.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.clcir!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.clcir!","text":"clcir!(vg::VOFGrid; iw=1, pn=1.5, igrid=1)\n\nPLIC reconstruction using the conservative level-contour (CLCIR). Same as ELCIR with a second-pass PLIC centroid update.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.compdt!-Tuple{VOFGrid, Vararg{Float64, 4}}","page":"Reference","title":"gVOF.compdt!","text":"compdt!(vg::VOFGrid, params::VOFParams, timet::Float64) -> Float64\n\nCompute the next time step dt from the CFL condition, with a 15 % growth limiter and a final-time guard.  Returns the new dt and also stores it in params.dt conceptually (caller must use the returned value).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.compgrid!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.compgrid!","text":"compgrid!(vg::VOFGrid)\n\nCompute face normals, face areas, face & cell centroids, cell volumes, bounding boxes and minimum cell sizes.  Mirrors Fortran COMPGRID.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.defcell-Tuple{VOFGrid, Int64}","page":"Reference","title":"gVOF.defcell","text":"defcell(vg::VOFGrid, ic::Int) -> Polyhedron3D\n\nConstruct the local Polyhedron3D representation of cell ic.  Face winding is reversed for faces where ic is the neighbour cell so that all face normals point outward.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.elcir!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.elcir!","text":"elcir!(vg::VOFGrid; iw=1, pn=1.5, igrid=1)\n\nPLIC reconstruction using the extended level-contour (ELCIR).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.emfp!-Tuple{Float64, Int64, Matrix{Float64}, Matrix{Float64}, Float64}","page":"Reference","title":"gVOF.emfp!","text":"emfp!(dt, nivface, vertp, vel, v) -> (ipv, nipv, nts, ntp, vertp_out, xns, yns, zns, vfactor)\n\nConstruct the edge-matched flux polyhedron.\n\nvertp[1:nivface,1:3] – face vertex coordinates\nvel[1:nivface,1:3]   – per-vertex velocity\nv                     – signed face-flux volume\n\nReturns arrays defining the polyhedron and a volume-correction factor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.faceflux!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.faceflux!","text":"faceflux!(vg::VOFGrid; dt, iadv=1, igrid=1, tolfr=1e-12)\n\nCompute the face volumetric fluxes vg.fface for every face in vg.isflu.  Uses the selected advection method (EMFP/FMFP/NMFP).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.fmfp!-Tuple{Float64, Int64, Matrix{Float64}, Matrix{Float64}, Float64}","page":"Reference","title":"gVOF.fmfp!","text":"fmfp!(dt, nivface, vertp_in, vel, v) -> (ipv, nipv, nts, ntp, vertp, xns, yns, zns, vfactor)\n\nConstruct the face-matched flux polyhedron.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.func3dendc-Tuple{Int64}","page":"Reference","title":"gVOF.func3dendc","text":"func3dendc(icase::Int) -> Function\n\nReturn the end-state level-set function (x,y,z) -> φ for test case icase.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.func3dinic-Tuple{Int64}","page":"Reference","title":"gVOF.func3dinic","text":"func3dinic(icase::Int) -> Function\n\nReturn the initial level-set function (x,y,z) -> φ for test case icase.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.funcexactvol-Tuple{Int64}","page":"Reference","title":"gVOF.funcexactvol","text":"funcexactvol(icase::Int) -> Float64\n\nReturn the analytical volume for test case icase.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.initfgrid!-Union{Tuple{F}, Tuple{VOFGrid, F, Int64, Float64}} where F","page":"Reference","title":"gVOF.initfgrid!","text":"initfgrid!(vg::VOFGrid, func3d, nc::Int, tolfr::Float64)\ninitfgrid!(vg::VOFGrid, func3d; nc=10, tolfr=1e-12)\n\nInitialise the volume fraction field vg.fractg by evaluating func3d(x, y, z) (positive inside the material) over each cell using VOFTools.initf3d.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.isrec-Tuple{Int64, Vector{Tuple{Float64, Float64, Float64}}}","page":"Reference","title":"gVOF.isrec","text":"isrec(iw, vertc) -> (xn, yn, zn)\n\nCompute the unit-length normal to an iso-surface polygon with centre at vertc[end] and edge mid-points at vertc[1:end-1].\n\niw selects the weighting scheme (1–6, see gVOF documentation).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.llcir!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.llcir!","text":"llcir!(vg::VOFGrid; iw=1, pn=1.5, igrid=1)\n\nPLIC reconstruction using the local level-contour iso-surface (LLCIR).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.lsfir!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.lsfir!","text":"lsfir!(vg::VOFGrid; pn=1.5, niter=4, tolir=0.001, igrid=1)\n\nPLIC reconstruction using least-squares fitting of PLIC centroids.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.lsfrec-NTuple{6, AbstractVector{Float64}}","page":"Reference","title":"gVOF.lsfrec","text":"lsfrec(vertcx, vertcy, vertcz, vnx, vny, vnz) -> (xn, yn, zn)\n\nLeast-squares fit reconstruction.  Fits a plane through the PLIC centroid positions using their normals as constraints.  The last element of each array is the reference cell.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.lsgir!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.lsgir!","text":"lsgir!(vg::VOFGrid; pn=1.5, igrid=1)\n\nPLIC reconstruction using a weighted least-squares gradient estimate.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.lsrec-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, Float64}","page":"Reference","title":"gVOF.lsrec","text":"lsrec(f, vertcx, vertcy, vertcz, pn) -> (xn, yn, zn)\n\nWeighted least-squares estimate of the interface normal.  The last element of each array is the reference cell.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.neigbcell!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.neigbcell!","text":"neigbcell!(vg::VOFGrid)\n\nPopulate vg.ineigb with neighbour-cell lists (cells sharing ≥ 1 node).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.nmfp!-Tuple{Float64, Int64, Matrix{Float64}, AbstractVector{Float64}, Float64}","page":"Reference","title":"gVOF.nmfp!","text":"nmfp!(dt, nivface, vertp_in, velface, v) -> (ipv, nipv, nts, ntp, vertp, xns, yns, zns, vfactor)\n\nConstruct the non-matched flux polyhedron (uniform back-translation). velface is a 3-vector (face-centred velocity).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.polv-Tuple{Int64, Float64, Matrix{Float64}}","page":"Reference","title":"gVOF.polv","text":"polv(np::Int, vcor::Float64, base_verts::Matrix{Float64}) -> (ie, apex)\n\nConstruct an apex point that gives a pyramid of volume vcor above the polygon defined by base_verts[1:np,1:3].\n\nReturns (ie, apex) where ie=1 on success, ie=0 if the polygon is degenerate.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.printgrid-Tuple{VOFGrid}","page":"Reference","title":"gVOF.printgrid","text":"printgrid(vg::VOFGrid; filename=\"grid.vtk\")\n\nWrite all grid faces to a VTK legacy-ASCII POLYDATA file.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.printplic-Tuple{VOFGrid, Int64}","page":"Reference","title":"gVOF.printplic","text":"printplic(vg::VOFGrid, ifile::Int; dir=\".\")\n\nWrite the PLIC interface polygons for the current reconstruction to plic-<ifile>.vtk in VTK legacy-ASCII POLYDATA format.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.printvoxel-Tuple{VOFGrid, Int64}","page":"Reference","title":"gVOF.printvoxel","text":"printvoxel(vg::VOFGrid, ifile::Int; dir=\".\", nvx=0, nvy=0, nvz=0)\n\nWrite a voxel-based volume-fraction field to voxel-<ifile>.vtk in VTK legacy-ASCII UNSTRUCTURED_GRID format.\n\nFor a uniform grid (igrid=1) the voxel grid matches the computational grid.  For other grid types a uniform overlay is used.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.recerr-Tuple{VOFGrid, Function}","page":"Reference","title":"gVOF.recerr","text":"recerr(vg::VOFGrid, func3d::Function; nc=10) -> (erec, erinit, vexact)\n\nCompute reconstruction and initialisation errors.\n\nerec   – symmetric-difference reconstruction error\nerinit – relative volume error |Vexact - Vinit| / V_exact\nvexact – exact material volume (from func3d)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.reconstruct!-Tuple{VOFGrid, VOFParams}","page":"Reference","title":"gVOF.reconstruct!","text":"reconstruct!(vg::VOFGrid, params::VOFParams)\n\nConvenience function that calls the reconstruction method specified by params.irec (1=CLCIR, 2=ELCIR, 3=LLCIR, 4=LSGIR, 5=SWIR, 6=LSFIR).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.swir!-Tuple{VOFGrid}","page":"Reference","title":"gVOF.swir!","text":"swir!(vg::VOFGrid; pn=1.5, niter=4, tolir=0.001, igrid=1)\n\nPLIC reconstruction using the Swartz iterative algorithm.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.swrec-Tuple{VOFGrid, Int64, Matrix{Float64}, Vector{Int64}, gVOF._ReconWork}","page":"Reference","title":"gVOF.swrec","text":"swrec(vg, ic, cplic, markplic; igrid) -> (xn, yn, zn)\n\nInner Swartz procedure for a single cell.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.vardef","page":"Reference","title":"gVOF.vardef","text":"vardef(filename::String=\"gvofvardef\") -> VOFParams\n\nRead a Fortran-style gvofvardef parameter file and return a VOFParams.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#gVOF.velgrid!-Tuple{VOFGrid, Int64, Float64, Float64}","page":"Reference","title":"gVOF.velgrid!","text":"velgrid!(vg::VOFGrid, icase::Int, timet0::Float64, timet::Float64)\n\nSet face and node velocities for one of the five standard test cases. Updates vg.velface, vg.velnode and vg.velcmax.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.vofgrid!-Tuple{VOFGrid, VOFParams}","page":"Reference","title":"gVOF.vofgrid!","text":"vofgrid!(vg::VOFGrid, params::VOFParams) -> VOFGrid\n\nReset an existing VOFGrid in-place for params, reusing all mutable runtime arrays. This is allocation-free when vg already matches the requested grid dimensions.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#gVOF.vofgrid-Tuple{VOFParams}","page":"Reference","title":"gVOF.vofgrid","text":"vofgrid(params::VOFParams) -> VOFGrid\n\nBuild a VOFGrid from simulation parameters.  Delegates the raw grid construction to ISOAP.constgrid and then pre-computes every auxiliary quantity needed by the VOF algorithms.\n\n\n\n\n\n","category":"method"},{"location":"grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"grid/#gVOF.vofgrid","page":"Grid","title":"gVOF.vofgrid","text":"vofgrid(params::VOFParams) -> VOFGrid\n\nBuild a VOFGrid from simulation parameters.  Delegates the raw grid construction to ISOAP.constgrid and then pre-computes every auxiliary quantity needed by the VOF algorithms.\n\n\n\n\n\n","category":"function"},{"location":"grid/#gVOF.vofgrid!","page":"Grid","title":"gVOF.vofgrid!","text":"vofgrid!(vg::VOFGrid, params::VOFParams) -> VOFGrid\n\nReset an existing VOFGrid in-place for params, reusing all mutable runtime arrays. This is allocation-free when vg already matches the requested grid dimensions.\n\n\n\n\n\n","category":"function"},{"location":"grid/#gVOF.compgrid!","page":"Grid","title":"gVOF.compgrid!","text":"compgrid!(vg::VOFGrid)\n\nCompute face normals, face areas, face & cell centroids, cell volumes, bounding boxes and minimum cell sizes.  Mirrors Fortran COMPGRID.\n\n\n\n\n\n","category":"function"},{"location":"grid/#gVOF.neigbcell!","page":"Grid","title":"gVOF.neigbcell!","text":"neigbcell!(vg::VOFGrid)\n\nPopulate vg.ineigb with neighbour-cell lists (cells sharing ≥ 1 node).\n\n\n\n\n\n","category":"function"},{"location":"grid/#gVOF.defcell","page":"Grid","title":"gVOF.defcell","text":"defcell(vg::VOFGrid, ic::Int) -> Polyhedron3D\n\nConstruct the local Polyhedron3D representation of cell ic.  Face winding is reversed for faces where ic is the neighbour cell so that all face normals point outward.\n\n\n\n\n\n","category":"function"},{"location":"reconstruction/#Reconstruction","page":"Reconstruction","title":"Reconstruction","text":"","category":"section"},{"location":"reconstruction/#gVOF.clcir!","page":"Reconstruction","title":"gVOF.clcir!","text":"clcir!(vg::VOFGrid; iw=1, pn=1.5, igrid=1)\n\nPLIC reconstruction using the conservative level-contour (CLCIR). Same as ELCIR with a second-pass PLIC centroid update.\n\n\n\n\n\n","category":"function"},{"location":"reconstruction/#gVOF.elcir!","page":"Reconstruction","title":"gVOF.elcir!","text":"elcir!(vg::VOFGrid; iw=1, pn=1.5, igrid=1)\n\nPLIC reconstruction using the extended level-contour (ELCIR).\n\n\n\n\n\n","category":"function"},{"location":"reconstruction/#gVOF.llcir!","page":"Reconstruction","title":"gVOF.llcir!","text":"llcir!(vg::VOFGrid; iw=1, pn=1.5, igrid=1)\n\nPLIC reconstruction using the local level-contour iso-surface (LLCIR).\n\n\n\n\n\n","category":"function"},{"location":"reconstruction/#gVOF.lsgir!","page":"Reconstruction","title":"gVOF.lsgir!","text":"lsgir!(vg::VOFGrid; pn=1.5, igrid=1)\n\nPLIC reconstruction using a weighted least-squares gradient estimate.\n\n\n\n\n\n","category":"function"},{"location":"reconstruction/#gVOF.swir!","page":"Reconstruction","title":"gVOF.swir!","text":"swir!(vg::VOFGrid; pn=1.5, niter=4, tolir=0.001, igrid=1)\n\nPLIC reconstruction using the Swartz iterative algorithm.\n\n\n\n\n\n","category":"function"},{"location":"reconstruction/#gVOF.lsfir!","page":"Reconstruction","title":"gVOF.lsfir!","text":"lsfir!(vg::VOFGrid; pn=1.5, niter=4, tolir=0.001, igrid=1)\n\nPLIC reconstruction using least-squares fitting of PLIC centroids.\n\n\n\n\n\n","category":"function"},{"location":"reconstruction/#gVOF.reconstruct!","page":"Reconstruction","title":"gVOF.reconstruct!","text":"reconstruct!(vg::VOFGrid, params::VOFParams)\n\nConvenience function that calls the reconstruction method specified by params.irec (1=CLCIR, 2=ELCIR, 3=LLCIR, 4=LSGIR, 5=SWIR, 6=LSFIR).\n\n\n\n\n\n","category":"function"},{"location":"tag-init/#Tagging-and-Initialization","page":"Tagging and Initialization","title":"Tagging and Initialization","text":"taggrid! is also part of the public API and is documented in the Reference section.","category":"section"},{"location":"tag-init/#gVOF.initfgrid!","page":"Tagging and Initialization","title":"gVOF.initfgrid!","text":"initfgrid!(vg::VOFGrid, func3d, nc::Int, tolfr::Float64)\ninitfgrid!(vg::VOFGrid, func3d; nc=10, tolfr=1e-12)\n\nInitialise the volume fraction field vg.fractg by evaluating func3d(x, y, z) (positive inside the material) over each cell using VOFTools.initf3d.\n\n\n\n\n\n","category":"function"},{"location":"tag-init/#gVOF.recerr","page":"Tagging and Initialization","title":"gVOF.recerr","text":"recerr(vg::VOFGrid, func3d::Function; nc=10) -> (erec, erinit, vexact)\n\nCompute reconstruction and initialisation errors.\n\nerec   – symmetric-difference reconstruction error\nerinit – relative volume error |Vexact - Vinit| / V_exact\nvexact – exact material volume (from func3d)\n\n\n\n\n\n","category":"function"},{"location":"#gVOF","page":"Home","title":"gVOF","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"gVOF\")","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"gVOF.jl is a Julia implementation of unsplit geometric VOF methods for structured and unstructured grids.\n\nMain capabilities:\n\nGrid preprocessing and geometric metrics\nInterface tagging and volume-fraction initialization\nMultiple PLIC reconstruction methods\nGeometric advection with flux polyhedra\nVTK output helpers for grid/interface/voxel fields","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using gVOF\n\nparams = VOFParams(nx = 32, ny = 32, nz = 32, igrid = 1, icase = 3)\nvg = vofgrid(params)\ninitfgrid!(vg, func3dinic(params.icase); nc = params.nc)\ntaggrid!(vg; tolfr = params.tolfr)\nreconstruct!(vg, params)","category":"section"},{"location":"#Main-Sections","page":"Home","title":"Main Sections","text":"Types\nGrid\nTagging and Initialization\nReconstruction\nAdvection\nOutput and Test Cases\nReference","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"Allocations free and fast execution.","category":"section"},{"location":"#Reference","page":"Home","title":"Reference","text":"Joaquín López, Julio Hernández, gVOF: An open-source package for unsplit geometric volume of fluid methods on arbitrary grids, Computer Physics Communications, Volume 277, 2022, 108400, ISSN 0010-4655, https://doi.org/10.1016/j.cpc.2022.108400.","category":"section"},{"location":"output-testcases/#Output-and-Test-Cases","page":"Output and Test Cases","title":"Output and Test Cases","text":"","category":"section"},{"location":"output-testcases/#gVOF.printgrid","page":"Output and Test Cases","title":"gVOF.printgrid","text":"printgrid(vg::VOFGrid; filename=\"grid.vtk\")\n\nWrite all grid faces to a VTK legacy-ASCII POLYDATA file.\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.printplic","page":"Output and Test Cases","title":"gVOF.printplic","text":"printplic(vg::VOFGrid, ifile::Int; dir=\".\")\n\nWrite the PLIC interface polygons for the current reconstruction to plic-<ifile>.vtk in VTK legacy-ASCII POLYDATA format.\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.printvoxel","page":"Output and Test Cases","title":"gVOF.printvoxel","text":"printvoxel(vg::VOFGrid, ifile::Int; dir=\".\", nvx=0, nvy=0, nvz=0)\n\nWrite a voxel-based volume-fraction field to voxel-<ifile>.vtk in VTK legacy-ASCII UNSTRUCTURED_GRID format.\n\nFor a uniform grid (igrid=1) the voxel grid matches the computational grid.  For other grid types a uniform overlay is used.\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.vardef","page":"Output and Test Cases","title":"gVOF.vardef","text":"vardef(filename::String=\"gvofvardef\") -> VOFParams\n\nRead a Fortran-style gvofvardef parameter file and return a VOFParams.\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.velgrid!","page":"Output and Test Cases","title":"gVOF.velgrid!","text":"velgrid!(vg::VOFGrid, icase::Int, timet0::Float64, timet::Float64)\n\nSet face and node velocities for one of the five standard test cases. Updates vg.velface, vg.velnode and vg.velcmax.\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.compdt!","page":"Output and Test Cases","title":"gVOF.compdt!","text":"compdt!(vg::VOFGrid, params::VOFParams, timet::Float64) -> Float64\n\nCompute the next time step dt from the CFL condition, with a 15 % growth limiter and a final-time guard.  Returns the new dt and also stores it in params.dt conceptually (caller must use the returned value).\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.func3dinic","page":"Output and Test Cases","title":"gVOF.func3dinic","text":"func3dinic(icase::Int) -> Function\n\nReturn the initial level-set function (x,y,z) -> φ for test case icase.\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.func3dendc","page":"Output and Test Cases","title":"gVOF.func3dendc","text":"func3dendc(icase::Int) -> Function\n\nReturn the end-state level-set function (x,y,z) -> φ for test case icase.\n\n\n\n\n\n","category":"function"},{"location":"output-testcases/#gVOF.funcexactvol","page":"Output and Test Cases","title":"gVOF.funcexactvol","text":"funcexactvol(icase::Int) -> Float64\n\nReturn the analytical volume for test case icase.\n\n\n\n\n\n","category":"function"},{"location":"advection/#Advection","page":"Advection","title":"Advection","text":"vofadv! is part of the exported API and listed in Reference.","category":"section"},{"location":"advection/#gVOF.emfp!","page":"Advection","title":"gVOF.emfp!","text":"emfp!(dt, nivface, vertp, vel, v) -> (ipv, nipv, nts, ntp, vertp_out, xns, yns, zns, vfactor)\n\nConstruct the edge-matched flux polyhedron.\n\nvertp[1:nivface,1:3] – face vertex coordinates\nvel[1:nivface,1:3]   – per-vertex velocity\nv                     – signed face-flux volume\n\nReturns arrays defining the polyhedron and a volume-correction factor.\n\n\n\n\n\n","category":"function"},{"location":"advection/#gVOF.fmfp!","page":"Advection","title":"gVOF.fmfp!","text":"fmfp!(dt, nivface, vertp_in, vel, v) -> (ipv, nipv, nts, ntp, vertp, xns, yns, zns, vfactor)\n\nConstruct the face-matched flux polyhedron.\n\n\n\n\n\n","category":"function"},{"location":"advection/#gVOF.nmfp!","page":"Advection","title":"gVOF.nmfp!","text":"nmfp!(dt, nivface, vertp_in, velface, v) -> (ipv, nipv, nts, ntp, vertp, xns, yns, zns, vfactor)\n\nConstruct the non-matched flux polyhedron (uniform back-translation). velface is a 3-vector (face-centred velocity).\n\n\n\n\n\n","category":"function"},{"location":"advection/#gVOF.faceflux!","page":"Advection","title":"gVOF.faceflux!","text":"faceflux!(vg::VOFGrid; dt, iadv=1, igrid=1, tolfr=1e-12)\n\nCompute the face volumetric fluxes vg.fface for every face in vg.isflu.  Uses the selected advection method (EMFP/FMFP/NMFP).\n\n\n\n\n\n","category":"function"}]
}
